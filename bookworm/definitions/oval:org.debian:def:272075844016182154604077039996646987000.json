{
	"id": "oval:org.debian:def:272075844016182154604077039996646987000",
	"class": "vulnerability",
	"metadata": {
		"title": "CVE-2022-48936 linux",
		"affected": {
			"family": "unix",
			"platform": "Debian GNU/Linux 12",
			"product": "linux"
		},
		"reference": [
			{
				"source": "CVE",
				"ref_id": "CVE-2022-48936",
				"ref_url": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-48936"
			}
		],
		"description": "In the Linux kernel, the following vulnerability has been resolved:  gso: do not skip outer ip header in case of ipip and net_failover  We encounter a tcp drop issue in our cloud environment. Packet GROed in host forwards to a VM virtio_net nic with net_failover enabled. VM acts as a IPVS LB with ipip encapsulation. The full path like: host gro -> vm virtio_net rx -> net_failover rx -> ipvs fullnat  -> ipip encap -> net_failover tx -> virtio_net tx  When net_failover transmits a ipip pkt (gso_type = 0x0103, which means SKB_GSO_TCPV4, SKB_GSO_DODGY and SKB_GSO_IPXIP4), there is no gso did because it supports TSO and GSO_IPXIP4. But network_header points to inner ip header.  Call Trace:  tcp4_gso_segment        ------> return NULL  inet_gso_segment        ------> inner iph, network_header points to  ipip_gso_segment  inet_gso_segment        ------> outer iph  skb_mac_gso_segment  Afterwards virtio_net transmits the pkt, only inner ip header is modified. And the outer one just keeps unchanged. The pkt will be dropped in remote host.  Call Trace:  inet_gso_segment        ------> inner iph, outer iph is skipped  skb_mac_gso_segment  __skb_gso_segment  validate_xmit_skb  validate_xmit_skb_list  sch_direct_xmit  __qdisc_run  __dev_queue_xmit        ------> virtio_net  dev_hard_start_xmit  __dev_queue_xmit        ------> net_failover  ip_finish_output2  ip_output  iptunnel_xmit  ip_tunnel_xmit  ipip_tunnel_xmit        ------> ipip  dev_hard_start_xmit  __dev_queue_xmit  ip_finish_output2  ip_output  ip_forward  ip_rcv  __netif_receive_skb_one_core  netif_receive_skb_internal  napi_gro_receive  receive_buf  virtnet_poll  net_rx_action  The root cause of this issue is specific with the rare combination of SKB_GSO_DODGY and a tunnel device that adds an SKB_GSO_ tunnel option. SKB_GSO_DODGY is set from external virtio_net. We need to reset network header when callbacks.gso_segment() returns NULL.  This patch also includes ipv6_gso_segment(), considering SIT, etc.",
		"debian": {}
	},
	"criteria": {
		"operator": "AND",
		"criterias": [
			{
				"operator": "OR",
				"criterias": [
					{
						"operator": "AND",
						"criterions": [
							{
								"test_ref": "oval:org.debian.oval:tst:2",
								"comment": "all architecture"
							},
							{
								"test_ref": "oval:org.debian.oval:tst:25900",
								"comment": "linux DPKG is earlier than 5.16.12-1"
							}
						]
					}
				]
			}
		],
		"criterions": [
			{
				"test_ref": "oval:org.debian.oval:tst:1",
				"comment": "Debian 12 is installed"
			}
		]
	}
}
