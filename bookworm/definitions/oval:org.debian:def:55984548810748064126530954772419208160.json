{
	"id": "oval:org.debian:def:55984548810748064126530954772419208160",
	"class": "vulnerability",
	"metadata": {
		"title": "CVE-2021-47089 linux",
		"affected": {
			"family": "unix",
			"platform": "Debian GNU/Linux 12",
			"product": "linux"
		},
		"reference": [
			{
				"source": "CVE",
				"ref_id": "CVE-2021-47089",
				"ref_url": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-47089"
			}
		],
		"description": "In the Linux kernel, the following vulnerability has been resolved:  kfence: fix memory leak when cat kfence objects  Hulk robot reported a kmemleak problem:      unreferenced object 0xffff93d1d8cc02e8 (size 248):       comm \"cat\", pid 23327, jiffies 4624670141 (age 495992.217s)       hex dump (first 32 bytes):         00 40 85 19 d4 93 ff ff 00 10 00 00 00 00 00 00  .@..............         00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................       backtrace:          seq_open+0x2a/0x80          full_proxy_open+0x167/0x1e0          do_dentry_open+0x1e1/0x3a0          path_openat+0x961/0xa20          do_filp_open+0xae/0x120          do_sys_openat2+0x216/0x2f0          do_sys_open+0x57/0x80          do_syscall_64+0x33/0x40          entry_SYSCALL_64_after_hwframe+0x44/0xa9     unreferenced object 0xffff93d419854000 (size 4096):       comm \"cat\", pid 23327, jiffies 4624670141 (age 495992.217s)       hex dump (first 32 bytes):         6b 66 65 6e 63 65 2d 23 32 35 30 3a 20 30 78 30  kfence-#250: 0x0         30 30 30 30 30 30 30 37 35 34 62 64 61 31 32 2d  0000000754bda12-       backtrace:          seq_read_iter+0x313/0x440          seq_read+0x14b/0x1a0          full_proxy_read+0x56/0x80          vfs_read+0xa5/0x1b0          ksys_read+0xa0/0xf0          do_syscall_64+0x33/0x40          entry_SYSCALL_64_after_hwframe+0x44/0xa9  I find that we can easily reproduce this problem with the following commands:  \tcat /sys/kernel/debug/kfence/objects \techo scan > /sys/kernel/debug/kmemleak \tcat /sys/kernel/debug/kmemleak  The leaked memory is allocated in the stack below:      do_syscall_64       do_sys_open         do_dentry_open           full_proxy_open             seq_open            ---> alloc seq_file       vfs_read         full_proxy_read           seq_read             seq_read_iter               traverse          ---> alloc seq_buf  And it should have been released in the following process:      do_syscall_64       syscall_exit_to_user_mode         exit_to_user_mode_prepare           task_work_run             ____fput               __fput                 full_proxy_release  ---> free here  However, the release function corresponding to file_operations is not implemented in kfence.  As a result, a memory leak occurs.  Therefore, the solution to this problem is to implement the corresponding release function.",
		"debian": {}
	},
	"criteria": {
		"operator": "AND",
		"criterias": [
			{
				"operator": "OR",
				"criterias": [
					{
						"operator": "AND",
						"criterions": [
							{
								"test_ref": "oval:org.debian.oval:tst:2",
								"comment": "all architecture"
							},
							{
								"test_ref": "oval:org.debian.oval:tst:22417",
								"comment": "linux DPKG is earlier than 5.15.15-1"
							}
						]
					}
				]
			}
		],
		"criterions": [
			{
				"test_ref": "oval:org.debian.oval:tst:1",
				"comment": "Debian 12 is installed"
			}
		]
	}
}
