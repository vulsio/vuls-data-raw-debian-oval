{
	"id": "oval:org.debian:def:23169164191548798767079822196784674452",
	"class": "vulnerability",
	"metadata": {
		"title": "CVE-2024-57889 linux",
		"affected": {
			"family": "unix",
			"platform": "Debian GNU/Linux 12",
			"product": "linux"
		},
		"reference": [
			{
				"source": "CVE",
				"ref_id": "CVE-2024-57889",
				"ref_url": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-57889"
			}
		],
		"description": "In the Linux kernel, the following vulnerability has been resolved:  pinctrl: mcp23s08: Fix sleeping in atomic context due to regmap locking  If a device uses MCP23xxx IO expander to receive IRQs, the following bug can happen:    BUG: sleeping function called from invalid context     at kernel/locking/mutex.c:283   in_atomic(): 1, irqs_disabled(): 1, non_block: 0, ...   preempt_count: 1, expected: 0   ...   Call Trace:   ...   __might_resched+0x104/0x10e   __might_sleep+0x3e/0x62   mutex_lock+0x20/0x4c   regmap_lock_mutex+0x10/0x18   regmap_update_bits_base+0x2c/0x66   mcp23s08_irq_set_type+0x1ae/0x1d6   __irq_set_trigger+0x56/0x172   __setup_irq+0x1e6/0x646   request_threaded_irq+0xb6/0x160   ...  We observed the problem while experimenting with a touchscreen driver which used MCP23017 IO expander (I2C).  The regmap in the pinctrl-mcp23s08 driver uses a mutex for protection from concurrent accesses, which is the default for regmaps without .fast_io, .disable_locking, etc.  mcp23s08_irq_set_type() calls regmap_update_bits_base(), and the latter locks the mutex.  However, __setup_irq() locks desc->lock spinlock before calling these functions. As a result, the system tries to lock the mutex whole holding the spinlock.  It seems, the internal regmap locks are not needed in this driver at all. mcp->lock seems to protect the regmap from concurrent accesses already, except, probably, in mcp_pinconf_get/set.  mcp23s08_irq_set_type() and mcp23s08_irq_mask/unmask() are called under chip_bus_lock(), which calls mcp23s08_irq_bus_lock(). The latter takes mcp->lock and enables regmap caching, so that the potentially slow I2C accesses are deferred until chip_bus_unlock().  The accesses to the regmap from mcp23s08_probe_one() do not need additional locking.  In all remaining places where the regmap is accessed, except mcp_pinconf_get/set(), the driver already takes mcp->lock.  This patch adds locking in mcp_pinconf_get/set() and disables internal locking in the regmap config. Among other things, it fixes the sleeping in atomic context described above.",
		"debian": {}
	},
	"criteria": {
		"operator": "AND",
		"criterias": [
			{
				"operator": "OR",
				"criterias": [
					{
						"operator": "AND",
						"criterions": [
							{
								"test_ref": "oval:org.debian.oval:tst:2",
								"comment": "all architecture"
							},
							{
								"test_ref": "oval:org.debian.oval:tst:32653",
								"comment": "linux DPKG is earlier than 6.1.124-1"
							}
						]
					}
				]
			}
		],
		"criterions": [
			{
				"test_ref": "oval:org.debian.oval:tst:1",
				"comment": "Debian 12 is installed"
			}
		]
	}
}
